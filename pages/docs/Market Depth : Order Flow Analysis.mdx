# ﻿Market Depth / Order Flow Analysis 

The **order book** is a list of currently open buy or sell orders, sorted by their quoted price and volume. Every broker and exchange maintains the order book. It can often be read by API functions and evaluated for getting an overview of the current market situation, as well as of the expected price trend when buy and sell orders are heavily imbalanced. 

The following functions can be used for retrieving order book data - also referred to as "market depth", "DOM", or "level 2" data - from the broker or from 

historical **.t2** data files. The data can be directly used for analyzing the order flow from the distribution of quotes and their volumes in the order book (**Zorro** 

## S required). 

BTC/USD June 2018, cumulative order volume distribution

The above histogram is generated from a order flow distribution analysis. The height of a bar is the cumulative volume of a price in the order book, blue for bid and red for ask prices. The volume is expressed as a 0..1 percentage of the total ask or bid volume, whichever is higher. You can see that the situation in the diagram is dominated by offers (100% vs. 65%), which might indicate a further 

falling bitcoin price.   

## orderUpdate (string Name, int Handle): int 

Retreives the current order book, and puts the list of open quotes in 

a **dataset** with the given **Handle** for further evaluation. In [***Test***] or [***Train***] mode the quotes are read from a historical data file **Name.t2** or **Name\_YYYY.t2** that is supposed to contain historical order book data. In [***Trade***] mode the order book is directly downloaded from the broker API with the **GET\_BOOK** command. 

Every **T2** record of the resulting dataset contains 3 fields: the timestamp, the quoted price (negative for bid), and the quoted volume. The **T2** struct is defined in **trading.h**. The function sets the **OrderRow** variable to the row of the first quote in the dataset, and returns the number of quotes open at the current time. 

## orderCVD (T2\* Quotes, int N, var Distance): int 

Generates a cumulative volume distribution of the price/volume pairs from the given **Quotes** list of **T2** records. The list is normally generated by a 

previous **orderUpdate** call. The **Quotes** pointer can be obtained from a dataset with **dataStr(Handle,OrderRow,0)**. **Distance** is the maximum deviation of the highest ask or lowest bid from the center price; quotes further away are not considered. The function returns the number of quotes within **Distance**.

## cpd(var Price): var 

Returns the cumulative relative volume of the given **Price**, in percent (0..100). 100 is equivalent to the total ask or bid volume, whichever is higher. Negative prices return the bid volume, positive prices the ask volume. 

## *Parameters:* 

## Name  Name of the order book file, without the trailing ".t2" and without a year number, or 0

name. 

## Handle  Handle of the dataset to receive the order book data. 

## Quote List of quotes in T2 format. 

## s 

## N  Number of quotes. 

## Distan Maximum order book range. 

## ce 

## Price  Quote price. 

## *Remarks:* 

The broker plugin must support the **GET\_BOOK** command for order flow analysis. **IB**, **IQFeed**, and many cryptocurrency exchanges support order book data. Other brokers or data sources can be implemented on request. 

For speed reasons **.t2** files are only read into the dataset when the end of the previous file is reached. Otherwise **orderUpdate** only updates **OrderRow**. When evaluating order book data for multiple assets, make sure to use a separate dataset with a different handle for any asset. 

## *Example:* 

## *// plot an order flow profile* void main()  

## { 

`  `**StartDate = 20180110;** 

`  `**LookBack = 0;** 

`  `**BarPeriod = 10;** 

`  `**PlotScale = 10;** 

`  `**set(PLOTNOW);** 

`  `**assetList("AssetsCrypto");   asset("BTC/USD");** 

## *// load today's order book* 

`  `**int N = orderUpdate("BTCUSD",1);** 

`  `**T2\* Quotes = dataStr(1,OrderRow,0);   printf("\nOrderbook: %i quotes",N);** 

`  `**var Distance = 0.05\*price(); *// +/- 5%*** 

`  `**int N2 = orderCVD(Quotes,N,Distance);** 

`  `**printf(", %i in range",N2);** 

`  `**Distance \*= 1.5;** 

`  `**var Price = priceClose() - Distance;** 

`  `**int i;** 

`  `**for(i=0; i<100; i++) {** 

`    `**Price += Distance/50;** 

`    `**plotBar("Ask",i,Price,cpd(Price),BARS|LBL2,RED);   }** 

`  `**Price = priceClose() - Distance;** 

`  `**for(i=0; i<100; i++) {** 

`    `**Price += Distance/50;** 

`    `**plotBar("Bid",i,Price,cpd(-Price),BARS|LBL2,BLUE);   }** 

## } 

## frechet (vars Data, int TimeFrame, var Scale, var\* Pattern) : var 

Calculates the Frechet distance between the recent part of a data series and a predefined curve. Returns a percent value equivalent to the similarity between the two curves. This function can be used for detecting cups, zigzags, or similar patterns in the price curve.*** 

## *Parameters:* 

## Data  The series to be compared. 

## TimeFra The number of bars in the series to be compared, or 0 for using the length of the pa

## me  size of the pattern. 

## Scale  The vertical size of the pattern (f.i. 10\*PIP for detecting a 10 pips tall pattern). Use a neg

pattern. 

## Pattern  The pattern shape to be detected in the series, given by an array of positive values 

and ends with **0** as an end mark. 

## *Returns* 

Similarity between **Data** and **Pattern** in percent, normally in the **20..80** range. ***Remarks:*** 

Related blog article: **Pattern recognition with the frechet distance** 

For determining a pattern array, paint the pattern on squared paper. The array values are equivalent to number of squares below any pattern segment. 

The algorithm is based on the **Fréchet distance**, a measure of similarity between two curves, often used for handwriting recognition. For the algorithm, imagine a dog walking along one curve and the dog's owner walking along the other curve. They are connected by a leash and walk from the start point to the end point of the curve. Both may vary their speed and even stop anytime, however neither can backtrack. The Fréchet distance is the length of the shortest possible leash required for traversing the curves in this manner. 

The absolute values of the pattern array don't matter, as it is normalized to **Scale** before comparison. The pattern is also aligned with the minimum of the **Data** series. For automatically adapting the pattern size to the data amplitude, set **Scale = MaxVal(Data,TimeFrame) - MinVal(Data,TimeFrame);**. 

Because series arrays have reverse time order, the pattern array is also reversed before comparison. This must be considered when comparing the pattern with a data array that is not a series. 

## *Example:* 

## *//detect 10-pip 10-bar cup formations in the price curve* function run() 

## { 

`  `**vars Price = series(price());** 

`  `**static var cup[10] = { 6,3,2,1,1,1,2,3,6,0 };** 

`  `**plot("Cup Similarity",frechet(Price, 0, 10\*PIP, cup),NEW,RED);** 

## } 
