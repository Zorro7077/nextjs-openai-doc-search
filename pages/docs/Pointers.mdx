# ﻿Pointers 

Pointers store references to variables. They point to the location in memory where the variable stores it's content. Pointers allow, for instance, the same function to do the same with different global variables, depending on what variable is currently referenced through a certain pointer. Pointers can be used like synonyms or alternative names for single variables or for arrays of variables. 

A pointer is defined by adding a '**\***' to the name, like this: 

## var \*mypointer; *// defines a pointer of type var with the name mypointer* 

The '\*' is also used for multiplication, but the compiler knows from the context if a pointer or a multiplication is meant. 

You can get a pointer to any variable by adding a '**&**' to the variable name: **var myvar = 77; mypointer = &myvar; *// now mypointer points to myvar*** 

You can see the '**&**' as the opposite of '**\***'. For accessing a variable that is the target of the pointer, add a '**\***' to the pointer name, just as in the pointer definition. This way the variable can be directly read or set: 

## \*mypointer = 66; *// now myvar contains 66* 

Pointers can also point to variable arrays, and can access their elements just by adding the usual **[0]**, **[1]**, ... etc. to the pointer name. In fact pointers and arrays are the same internal type. When **mypointer** is a pointer to an 

array, **mypointer+n** is a pointer to the **n**-th element of that array. Therefore for accessing elements of the array, **\*mypointer** points to the same as element 

as **mypointer[0]** and **\*(mypointer+n)** points to the same element 

as **mypointer[n]**. 

## *Variable pointers in functions* 

There can be some situation where variable pointers might be useful. Normally if you pass a variable to a function, the function works merely with a copy of that variable. Changing the variable within the function only affects the copy. However if you pass the pointer to a variable, the function can change the original variable. For getting a pointer to a variable, just place a '**&**' before the variable name. Example:** 

## function change\_variable(var myvar) 

## { 

`  `**myvar += 1;** 

## } 

## function change\_variable\_p(var \*myvar) 

## { 

`  `**\*myvar += 1;** 

## } 

## ... 

## var x = 10; 

## change\_variable(x);   *// now x is still 10* change\_variable\_p(&x); *// now x is 11* 

Lite-C automatically detects if a function expects a variable or a pointer to a variable, so you can usually omit the '**&**' and just write: 

## change\_variable\_p(x); *// now x is 1* *Arrays of pointers or series* 

When accessing elements in an array of pointers or **series**, parentheses must be used:** 

## vars MySeriesArray[3]; *// declars an array of series*  

## ... 

## for(i=0; i<3; i++) MySeriesArray[i] = series(); 

## ... 

## (MySeriesArray[0])[0] = 123; *// access the first element of the first array. Mind the parentheses!* 

## *Function pointers* 

A function pointer is defined just as a function prototype with return and parameter types. Example:** 

## float myfunction(int a, float b); *// define a function pointer named "myfunction"*   

## float fTest(int a, float b) { return (a\*b); } ... 

## myfunction = fTest; 

## x = myfunction(y,z); 

For storing arrays of function pointers in C, **void\*** arrays can be used. Example: **float myfunction(int a, float b); *// define a function pointer*** 

## void\* function\_array[100];        *// define a pointer array* 

## float fTest(int a, float b) { return (a\*b); } ... 

## function\_array[n] = fTest; 

## myfunction = function\_array[n]; 

## x = myfunction(y,z); 
